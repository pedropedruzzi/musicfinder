\chapter{Técnicas e procedimentos usados}
\label{chap:tecnicas}
% TODO
Neste capítulo será descrito em detalhes todo o desenvolvimento do presente trabalho. Serão mostradas as técnicas utilizadas, seus fundamentos e objetivos.

\section{Processo de extração de notas}
% TODO

\section{Representação de notas e melodias}
\label{sec:notas}
A seção anterior descreveu o processo de extração de notas. Conforme foi visto, este processo analisa uma amostra de áudio de duração típica de três a quinze segundos, e produz uma tabela contendo os seguintes dados sobre as notas extraídas: altura (freqüência fundamental de vibração ou \emph{pitch}) e tempos de início e fim. Vale observar que nesta tabela as notas aparecem ordenadas cronológicamente e que não há sobreposição temporal destas.

A representação tabular guarda todas as informações musicais da melodia extraída e, portanto, define o formato de entrada para consultas ao mecanismo de busca musical. Porém, internamente a este mecanismo, as melodias são representadas na forma de listas de eventos musicais. Neste modelo interno, um evento musical pode ser uma nota ou um silêncio\footnote{ou \emph{pausa}}, e guarda suas duas características fundamentais: altura e duração. A altura é mantida em \emph{Hertz} e a duração em segundos. Para simplificar a representação, adotou-se um valor zero para a altura dos silêncios. A adoção desta representação justifica-se por uma questão de conveniência, uma vez que os algoritmos do mecanismo de busca são fundamentalmente baseados em listas.

Musicalmente os silêncios, ou pausas, são considerados elementos tão importantes quanto as própias notas. Porém analisando reproduções de uma mesma melodia por diferentes interpretes, nota-se uma maior simetria nos ataques\footnote{inícios} das notas do que em seus fins. Assim, o tempo de ressonância das notas, e a duração dos silêncios é muito variável. Ao contrário dos intervalos entre os ataques, que tende a se manter mais estável.

Conclui-se, portanto, que os intervalos entre os ataques das notas é mais relevante do que as durações exatas das notas e silêncios para definição da característica psicoacústica de uma melodia. Por este motivo, para os fins deste trabalho, os silêncios foram eliminados das representações. Para manter a característica da distância temporal entre ataques de notas, a duração de cada silêncio foi incorporada à duração da nota imediatamente anterior.

\section{Proximidade de melodias}
Quando uma pessoa canta uma melodia ou a toca em um instrumento, somos eventualmente capazes de identificar a que música aquela melodia pertence. Nosso cérebro é capaz de reconhecer estas semelhanças mesmo na presença de variações ou imprecisões na melodia que ouvimos.

Um exemplo típico de tais variações é a transposição tonal, em que a melodia é reproduzida com uma variação fixa\footnote{Variação fixa na escala logarítmica significa o produto por uma constante} na altura de todas as notas, para mais ou para menos. Outro exemplo é a dilatação ou contração das durações das notas que compõe aquela melodia.

Em muitos casos, somos capazes de identificar músicas mesmo na ocorrência de \emph{erros} na reprodução, tais como uma nota errada (com altura diferente), ou mesmo a omissão ou adição de notas à melodia original. Estes erros são, em geral, provenientes da incapacidade ou imprecisão do próprio executor.

\section{Comparação numérica}
Em uma situação hipotética onde não há presença de erros, pode-se analisar a proximidade entre duas melodias com a mesma quantidade de notas, definindo um modelo matemático que mapeia as notas de uma melodia nas notas da outra. Sendo $p_1$ e $p_2$, respectivamente as alturas de uma nota do trecho 1 e sua correspondente no trecho 2; e $d_1$ e $d_2$ as durações destas; a relação que mapeia as durações é do tipo: \[ d_1 = A.d_2\]

A constante $A$ representa uma proporcionalidade entre as durações, portanto o modelo adotado permite dilatações e contrações proporcionais.

Para mapear as alturas utiliza-se a seguinte relação: \[ \log p_1 = \log p_2 + B \]

A constante $B$ representa a transposição tonal. A relação logarítmica é necessária pelo fato de que a percepção do ouvido humano para alturas de notas é exponencial.

A partir destas relações de aproximação, calculam-se os parâmetros $A$ e $B$ que melhor aproximam a distribuição segundo o critério de proximidade do método dos mínimos quadrados, isto é, aqueles que minimizem a soma dos erros quadráticos:

\begin{equation} \label{E:errorDuration}
S_d = \sum_{i=1}^N (A.d_{2i} - d_{1i})^2
\end{equation}
\begin{equation} \label{E:errorPitch}
S_p = \sum_{i=1}^N (\log p_{2i} + B - \log p_{1i})^2
\end{equation}

A teoria \cite{calculoNumerico} nos mostra que o mínimo de cada uma destas funções ocorre quando suas derivadas com relação ao parâmetro atingem o valor zero:

\[ \frac{\partial S_d}{\partial A} = 0 \]
\[ 2 \sum_{i=1}^N (A.d_{2i} - d_{1i}) d_{2i} = 0 \]
\[ \sum_{i=1}^N (A.d_{2i}^2 - d_{1i}d_{2i}) = 0 \]
\begin{equation} \label{E:paramDuration}
A = \frac{\sum_{i=1}^N d_{1i}d_{2i} }{\sum_{i=1}^N d_{2i}^2 }
\end{equation}

\[ \frac{\partial S_p}{\partial B} = 0 \]
\[ 2 \sum_{i=1}^N (\log p_{2i} + B - \log p_{1i}) = 0 \]
\[ \sum_{i=1}^N (\log \frac{p_{2i}}{p_{1i}} + B) = 0 \]
\begin{equation} \label{E:paramPitch}
B = \frac { \sum_{i=1}^N \log \frac{p_{2i}}{p_{1i}} } { N }
\end{equation}

Os valores $A$ e $B$ obtidos, eventualmente podem ser utilizados para avaliar a proximidade entre as melodias. Porém, nesta modelagem, o relevante não são os parâmetros obtidos da redução, e sim, a soma quadrática dos erros ao utilizá-los, dados pelas equações~\ref{E:errorDuration} e~\ref{E:errorPitch}.

Quanto menor forem os valores destas somas, mais próximas são as melodias comparadas. A distância entre estas é então definida por uma soma ponderada destes valores, com pesos ajustáveis:
\begin{equation} \label{E:distance}
d = \alpha S_d + \beta S_p
\end{equation}

\section{Busca inexata com automato adaptativo}

Com a definição de proximidade entre melodias apresentada acima, seria possível construir um mecanismo de busca de uma melodia sobre um repositório de músicas, utilizando uma janela deslizante do tamanho da melodia de entrada e varrendo sobre todas as melodias do repositório. Porém tal mecanismo só seria efetivo no caso restrito em que a melodia de entrada não possui imperfeições como a ausência ou adição de notas.

Conforme já discutido anteriormente, estas imperfeições ocorrem com certa freqüência e, em condições habituais, não são suficientes para impedir que uma pessoa seja capaz de identificar a música executada. Esta consideração motiva a idealização de um mecanismo de comparação que seja capaz de lidar com tais imperfeições.

No capítulo~\ref{chap:historico}, diversas abordagens dadas a este problema foram apresentadas. Porém, não se localizou na literatura nenhum estudo que cite o uso de técnicas adaptativas com este fim. Propõe-se, então, um novo método de reconhecimento de padrões musicais baseado em autômatos adaptativos.

Neste método, constrói-se um autômato adaptativo \cite{Neto94} automaticamente, a partir da melodia de entrada (consultada), que funciona como um reconhecedor de melodias semelhantes a esta. Este autômato então, é utilizado para processar todo o repositório de melodias e elencar as melhores semelhanças.

Como já foi dito anteriormente, a utilização deste formalismo para a comparação de melodias vem da necessidade de reconhecer melodias contendo imprecisões, naturais da reprodução humana. Sendo assim, o autômato foi projetado para lidar com três tipos de situações de erro na melodia de entrada. São elas:

\begin{enumerate}
\item Omissão de uma nota

Situação em que uma nota da melodia procurada foi omitida da melodia de entrada.

\item Adição de uma nota

Situação em que uma nota que não faz parte da melodia procurada foi inserida na melodia de entrada.

\item Troca de uma nota

Situação em que uma nota da melodia procurada foi substituída por outra qualquer na melodia de entrada.
\end{enumerate}

\section{Notas como símbolos}

Para ser capaz de processar melodias (tanto a da consulta como as da base de dados), o autômato precisa enxergá-las na forma de cadeias de símbolos de um alfabeto finito. Como nesta etapa deseja-se especificamente reconhecer melodias contornando os três tipos de erros enumerados anteriormente, pode-se considerar apenas a altura das notas, desprezando inicialmente as durações.

Porém, os valores possíveis de altura das notas constituem um domínio contínuo e portanto precisam ser ajustados para um domínio discreto, que constituirá o alfabeto do autômato. Para este domínio discreto, escolheu-se utilizar o conjunto de alturas das notas de um piano. Este conjunto, conhecido musicalmente como \emph{temperamento igual de 12 tons}, é o sistema de afinação predominantemente utilizado na música ocidental moderna \cite{Burns99}.

O MIDI\footnote{Musical Instrument Digital Interface} \cite{midi} é um padrão de facto que define um protocolo para comunicação entre instrumentos musicais eletrônicos e outros equipamentos de áudio. Entre os diversos outros detalhes do protocolo, o MIDI define um código para representação das notas do sistema de afinação ocidental (notas do piano). Este código é um número inteiro entre 0 e 127, que é capaz de representar muito além da capacidade audível da maioria dos seres humanos. A nota 0, por exemplo, é uma nota Dó cinco oitavas abaixo do Dó central e corresponde a uma freqüência de 8,176 Hz. Por conveniência, adotaremos este código de notas MIDI como alfabeto do autômato.

A primeira etapa do ajuste de domínio é basicamente uma conversão de unidades. A conversão da altura em Hertz para o código MIDI é dada pela seguinte relação:
$$ p = 69 + 12\times\log_2 { \left(\frac {f}{440\,\mbox{Hz}} \right) }. $$

Após esta conversão é necessário realizar uma quantização a fim de obter valores inteiros, discretizando o domínio. Note, porém, que este processo não é tão simples quanto um arredondamento. Pois o que define a característica perceptiva de uma melodia é a relação entre as alturas das notas e não seus valores absolutos, haja visto que a transposição tonal não altera esta característica. Sendo assim, um simples arredondamento poderia ocasionar erros de quantização consideráveis.

Outro aspecto a se considerar é que o executor da melodia, pode perder a referência absoluta de afinação durante sua reprodução. Ou seja, para uma melodia suficientemente grande, a referência de afinação para uma determinada nota vem das $k$ notas anteriores e não da melodia inteira.

Considerando este aspecto relativo da reprodução humana, uma pesquisa da Universidade de Waikato (Nova Zelândia) apresentou um simples e interessante método de quantizar estes valores a partir da referência de afinação da nota anterior.

Este método foi reproduzido e testado utilizando valores extraídos de gravações de melodias assobiadas. Porém, os resultados mostraram que, em alguns casos, ocorre uma divergência elevada, maior que eventuais variações da referência absoluta do executor. O gráfico da figura~\ref{fig:quant-rel} ilustra um destes casos.

\begin{figure}[htb]
	\center{\includegraphics{figuras/quant-rel.eps}}
	\caption{\label{fig:quant-rel} Alturas quantizadas pelo método relativo}
\end{figure}

Tendo em vista as limitação deste método de quantização relativo, foi desenvolvido um método de quantização absoluto que será descrito em detalhes na seção seguinte.

\subsection{Quantização absoluta das alturas das notas}

O método proposto parte do princípio que a melodia original pode ser transposta de tonalidade livremente, ou seja, pode-se somar uma constante em todas as notas sem que o resultado da quantização perca significado. A partir disto encontra-se analiticamente a constante que minimiza uma métrica de erro de quantização e, por fim, faz-se o arredondamento das notas somadas a esta constante.

A soma do erro quadrático de quantização por arredondamento é dada por:
\[ E(0) = \sum_{i=1}^N (p_i - \lfloor p_i + \frac{1}{2} \rfloor)^2\]

Com a adição de uma constante $c$ em todos os valores, torna-se:
\[ E(c) = \sum_{i=1}^N (p_i + c - \lfloor p_i + c + \frac{1}{2} \rfloor)^2\]

Este valor varia com a constante $c$. Em suma, queremos encontrar o valor de $0 < c \leq 1$ que minimiza $E$, para então obter os valores quantizados $v_i$ da seguinte maneira:
\[ v_i = \lfloor p_i + c + \frac{1}{2} \rfloor.\]

Note que a função $E$ não é contínua. Por este motivo, seu mínimo pode estar ou nos pontos de descontinuidade ou nos pontos em que:
\begin{equation} \label{E:dE}
\frac{\partial E}{\partial c} = 0.
\end{equation}

Os pontos de descontinuidade ocorrem quando $c = \frac{1}{2} + \lfloor p_i + \frac{1}{2} \rfloor - p_i + k$, $k \in \mathbb{Z}$, para qualquer $p_i$. Estes pontos são candidatos a mínimo de $E$. Entre dois destes pontos consecutivos $c_1$ e $c_2$, $E$ é contínua e então podemos desenvolver a equação ~\ref{E:dE}:
\begin{equation} \label{E:dE2}
\sum_{i=1}^N (p_i + c - \lfloor p_i + c + \frac{1}{2} \rfloor) = 0
\end{equation}

Por termos restringido o intervalo para uma região contínua, o termo $\lfloor p_i + c + \frac{1}{2} \rfloor$ agora passa a ser constante. Para calculá-lo basta utilizar para $c$ um valor qualquer do intervalo, como por exemplo a média dos extremos:
$$ \bar{c} = \frac{c_1+c_2}{2}$$

Com isso a equação ~\ref{E:dE2} fica:
\begin{equation} \label{E:dE3}
c = \frac { \sum_{i=1}^N (\lfloor p_i + \bar{c} + \frac{1}{2} \rfloor - p_i) } { N }
\end{equation}

Se o valor obtido para $c$ estiver no intervalo $\left]c_1,c_2\right[$ este será solução da equação ~\ref{E:dE} e, portanto, um novo canditado a mínimo de $E$.
Aplica-se este procedimento para todos os trechos entre pontos de descontinuidade do intervalo $\left]0,1\right]$ e obtem-se desta forma todos os candidatos a mínimo de $E$. Basta verificar os valores de $E$ para cada candidato e escolher aquele que a minimiza.

O gráfico da figura~\ref{fig:quant-cmp} mostra uma comparação dos resultados dos dois métodos de quantização utlizando a mesma melodia da figura~\ref{fig:quant-rel}.

\begin{figure}[htb]
	\center{\includegraphics{figuras/quant-cmp.eps}}
	\caption{\label{fig:quant-cmp} Comparação dos dois métodos de quantização de alturas}
\end{figure}

\subsection{Construção do autômato adaptativo}
	
A configuração inicial do autômato adaptativo é obtida através da cadeia de entrada do processo de busca, isto é, a cadeia a ser localizada no repositório. Seja a cadeia de entrada $v_i$, $i=0,\ldots,N-1$. O autômato é construído inicialmente com $N+1$ estados, numerados de $0$ a $N$, onde apenas o estado $N$ é final. Adiciona-se transições do estado $i$ para o estado $i+1$ com o símbolo $v_i$, para $i=0,\ldots,N-1$.

Para ilustrar o funcionamento do autômato, considere a seguinte seqüência de notas: 69, 71, 73, 74, 76, 77, 76. A figura~\ref{fig:adapt1} mostra a configuração inicial do autômato adaptativo gerado para esta seqüência.

\begin{figure}[htb]
	\center{\includegraphics{figuras/adapt1.eps}}
	\caption{\label{fig:adapt1} Configuração inicial do autômato adaptativo}
\end{figure}

A execução do autômato sobre uma cadeia qualquer inicia-se com o cálculo de uma constante de transposição. Esta constante nada mais é do que a diferença entre a primeira nota da cadeia de entrada e a da cadeia que originou o autômato. Este valor é descontado dos símbolos de entrada a cada leitura, e serve fundamentalmente para desfazer uma possível transposição tonal.

O caminho definido pelos estados de $0$ a $N$, deste ponto adiante chamado de caminho de referência, ocorre quando a cadeia de entrada equivale exatamente à cadeia procurada, a menos da constante de transposição.

Estando no caminho de referência, ao receber um símbolo para o qual não existe transição, ocorre uma ação adaptativa em que uma estrutura de novos estados e transições é incorporanda ao autômato a partir do estado corrente.

Suponha que o autômato da figura~\ref{fig:adapt1} recebeu na entrada as notas 69 e 71, atingindo o estado 2. Em seguida, o autômato recebeu o símbolo 74 e disparou a ação adaptativa. A figura~\ref{fig:adapt2} mostra a configuração deste autômato após esta ação.

\begin{figure}[htb]
	\center{\includegraphics{figuras/adapt2.eps}}
	\caption{\label{fig:adapt2} Configuração do autômato após ação adaptativa 1}
\end{figure}

O autômato atinge o novo estado 8 e, a partir das novas transições incorporadas, torna-se capaz de lidar com as três situações de erro.
\begin{enumerate}
\item Omissão de uma nota

Se a nota 74 recebida fora omitida da cadeia que gerou o autômato, o reconhecimento volta para o caminho de referência a partir do estado 3 ao receber a nota 73, que esperava anteriormente.

\item Adição de uma nota

Se a nota 73, que era esperada, fora inserida erroneamente na cadeia que gerou o autômato, o reconhecimento volta para o caminho de referência a partir do estado 5 ao receber a próxima nota da seqüência: 76.

\item \label{i:troca} Troca de uma nota

Se a nota 74 fora trocada por engano pela 73 na cadeia que gerou o autômato, o reconhecimento volta para o caminho de referência a partir do estado 4 ao receber a nota seguinte: 74.
\end{enumerate}

Note que o caso de adição de uma nota só pôde ser contornado por que a nota recebida coincidiu com a segunda nota esperada do autômato. Quando isto não ocorrer, a transição que contorna este caso não é gerada. Um exemplo desta situação pode ser observado na figura~\ref{fig:adapt3}.

\begin{figure}[htb]
	\center{\includegraphics{figuras/adapt3.eps}}
	\caption{\label{fig:adapt3} Configuração do autômato após ação adaptativa 2}
\end{figure}

É importante observar que este autômato é capaz de reconhecer melodias contendo múltiplos erros, desde que devidamente espaçados. A ocorrência de dois erros consecutivos implica na não aceitação da cadeia, pois não há ações adaptativas nos estados fora do caminho de referência. Tal possibilidade implicaria em um tratamento muito mais complexo das possibilidades de combinação de erros e transições de recuperação.

Uma limitação importante deste tipo autômato é percebida em situações em que as transições de recuperação de erro são conflitantes. No exemplo apresentado, as transições de recuperação de erro são indepententes, por serem disparadas com símbolos diferentes. Porém, em alguns casos, quando as melodias possuem notas repetidas, transições de recuperação diferentes podem ser disparadas com um mesmo símbolo. Neste casos, para evitar o não-determinismo do autômato, elimina-se a transição de menor prioridade. Os casos de erro em ordem decrescente de prioridade são: adição, troca e omissão.

Durante o reconhecimento de uma cadeia, o autômato registra um código de resultado para cada nota lida, em uma lista. Quando a nota recebida era esperada, o algoritmo registra \texttt{OK}. Quando a nota não era esperada o algoritmo registra o código da situação de erro ocorrida: \texttt{EXCHANGE}, \texttt{ADDITION} ou \texttt{OMISSION}. Note que neste caso o resultado depende da transição de recuperação que for utilizada e só pode ser determinado ao tratar a nota seguinte.

Quando o autômato atinge o estado final, a cadeia é considerada aceita e a lista de código de resultado representa os detalhes do reconhecimento. Caso contrário, a cadeia é rejeitada, porém, para se saber até que ponto a cadeia foi reconhecida retorna-se a lista de código de resultado parcial. Esta lista contém os resultado até o momento em que a cadeia foi rejeitada.

Abaixo segue uma simulação de execução do autômato da figura~\ref{fig:adapt1}, para cadeias de entrada contendo cada uma das três situações de erro descritas a pouco. Primeiramente mostra-se a cadeia utilizada para construção do autômato. Esta cadeia representa a consulta ao sistema de busca. Em seguida, entra-se com cadeias para serem processadas pelo autômato, representando trechos de melodias da base de dados. Para cada entrada o autômato retorna a lista de códigos de resultado.

\begin{listagem}
\begin{verbatim}
Cadeia para produzir o autômato:
69 71 73 74 76 77 76 0

Exemplo de troca:
69 71 74 74 76 77 76 0
[OK, OK, EXCHANGE, OK, OK, OK, OK]

Exemplo de adição:
69 71 74 76 77 76 0
[OK, OK, ADDITION, OK, OK, OK]

Exemplo de omissão:
69 71 72 73 74 76 77 76 0
[OK, OK, OMISSION, OK, OK, OK, OK, OK]
\end{verbatim}
\caption{Resumo da simulação de execução do autômato}
\end{listagem}


\begin{listagem}
\begin{verbatim}
Entre com uma cadeia terminada por 0 para gerar o autômato:
69 71 73 74 76 77 76 0
Digite:
	1, para digitar uma cadeia de entrada.
	2, para gerar uma cadeia de entrada.
	0, para sair.
1
Entre com a cadeia de entrada terminando com 0:
69 71 74 74 76 77 76 0
true
[OK, OK, EXCHANGE, OK, OK, OK, OK]
Digite:
	1, para digitar uma cadeia de entrada.
	2, para gerar uma cadeia de entrada.
	0, para sair.
1
Entre com a cadeia de entrada terminando com 0:
69 71 74 76 77 76 0
true
[OK, OK, ADDITION, OK, OK, OK]
Digite:
	1, para digitar uma cadeia de entrada.
	2, para gerar uma cadeia de entrada.
	0, para sair.
1
Entre com a cadeia de entrada terminando com 0:
69 71 72 73 74 76 77 76 0
true
[OK, OK, OMISSION, OK, OK, OK, OK, OK]
Digite:
	1, para digitar uma cadeia de entrada.
	2, para gerar uma cadeia de entrada.
	0, para sair.
\end{verbatim}
\caption{Saída completa da simulação de execução do autômato}
\end{listagem}

Uma cadeia ser aceita pelo autômato significa na prática que contornando eventuais situações de erro devidamente isoladas as cadeias são semelhantes. A partir deste momento a lista de códigos de resultados é analisada com o objetivo de mensurar a distância entre as cadeias comparadas.

Para esta análise, dois aspectos são considerados. O primeiro deles é direto e correponde à quantidade de erros observados. Quanto menor o número de erros mais próximas são as cadeias. O segundo aspecto envolve um procedimento mais elaborado. Note que a partir da cadeia que originou o autômato e da lista de códigos de resultados, é possível construir uma cadeia artificial, corrigindo os erros registrados. Assim se, por exemplo, uma nota for omitida, pode-se readicioná-la à cadeia. O objetivo desta reconstrução é possibilitar a aplicação dos métodos numéricos de comparação nota a nota apresentados anteriormente. Principalmente com relação às durações das notas, aspecto que fora desconsiderado nesta nova abordagem até então.

Algumas considerações são importantes no que tange à reconstrução da cadeia com base nas informações de erros. Para notas trocadas deve-se manter a duração original. Para notas omitidas, estas deverão ser readicionadas com duração zero para que não haja interferência no contorno temporal geral da cadeia. A nota é adicionada somente para alinhar o emparelhamento necessário para a comparação nota a nota. E, por fim, para o o caso de notas adicionadas, estas são retiradas e sua duração é incorporada à nota imediatamente anterior.

Com base nestas considerações constrói-se a cadeia corrigida e, executando o procedimento de comparação de durações, consegue-se obter uma nova métrica de distância entre as melodias, desta vez utilizando métodos numéricos e considerando as durações das notas.

\subsection{Critério para avaliar a semelhança entre melodias}

Com o modelo de comparação que foi definido, tem-se algumas métricas para avaliação da semelhança entre melodias. A primeiras delas é se o autômato chegou ou não ao estado final. Outra métrica é representada pela lista de códigos de resultado e, por fim, a distância numérica das durações.

Existe uma relação de importância que cada um destes fatores têm sobre a semelhança global percebida. Porém, a falta de testes massivos impede uma percepção apurada destas importâncias e por conseqüência impossibilita a atribuição de pesos para cada fator.

Porém, faz-se necessário definir um critério simples e direto com o objetivo de classificar as correspondencias encotradas. Adotou-se para este fim a contagem dos erros a partir da lista de códigos de resultado. Para as listas parciais (quando a cadeia não é aceita), somou-se à contagem de erros o número de notas que sobraram no momento em que o reconhecimento parou.

\subsection{Busca}

Sumarizando o procedimento de busca, temos inicialmente a construção do autômato adaptativo a partir da melodia de entrada quantizada. Em seguida aplica-se o autômato sobre todas as melodias do repositório. Este é aplicado inicialmente à cadeia que corresponde a uma melodia completa. Em seguida, a primeira nota desta cadeia é eliminada e o autômato é aplicado novamente. E assim sucessivamente até que a cadeia torne-se vazia, então parte-se para a próxima melodia do repositório.

Ao longo deste processo, o mecanismo de busca mantém um conjunto com as N melhores correspondências que encontrou, com base no critério definido a pouco. Desta forma, ao final da varredura de todo o repositório, tem-se os resultados da busca.

